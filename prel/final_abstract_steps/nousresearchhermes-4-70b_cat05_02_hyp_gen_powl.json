[
  {
    "Name": "Pattern Recognition - PE",
    "Text": "We are given a POWL model with anomalies. Lets break down the task: 1. Identify the anomalies in the given POWL model: a. Loop between Evaluate E and Approve P: The loop structure E P allows for: Starting with E then optionally followed by P and then back to E. This could lead to: Multiple approvals P for a single claim without necessarily having a new evaluation But note: the loop requires E then P so each cycle has E and P. However it might be that an approval is followed by another evaluation and then another approval which might be intended for iterative reviews but could be an anomaly if the claim should be approved only once. The loop might also allow for skipping the approval step Not exactly: the loop operator in pm4py Operator.LOOP typically means: do the first child E and then in the loop you can choose to do the sequence of the remaining children P and then E again repeatedly. But note: the children are E P. The loop operator with two children is described as: do E then optionally do P and then E again. So the loop body is actually P and then E and we start with an E. So the pattern is: E P E Actually the loop in pm4py Operator.LOOP with children A B means: A and then a loop that can do B and then A again The standard process tree loop operator is: Start by doing the first child A. Then you can repeatedly zero or more times do the second child B and then the first child A again. However note that the documentation says: LOOP loop: Enables a loop construct. The first child is executed and then the second child can be executed possibly multiple times. The loop can be broken by skipping the second child. But in our case the loop has two children: E P. So the intended behavior is: Execute E Evaluate Claim Then in the loop body: we can choose to do P Approve Claim and then E again repeatedly until we break the loop. However note that the loop does not require the P step Actually the loop operator in pm4py allows the second child P to be executed multiple times But the structure is: First do E. Then for each iteration of the loop we do P and then E. So the pattern is: E P E meaning that we have one or more evaluations and the number of approvals equals the number of times we went through the loop. But note: the first E is mandatory and then each loop iteration requires P and then E. So we have: At least one approval Not exactly: we can break the loop after the first E without doing any P Actually no: because the loop body is the second child P and then the first child E again But wait the loop operator in pm4py as per the standard is defined as: The first child is executed. Then we can execute the second child followed by the first child again as long as we want including zero times. So the pattern is: We start with E mandatory. Then we can choose to execute P followed by E zero or more times But note: the loop operator in pm4py Operator.LOOP requires that the first child E is done at least once and then the second child P and then the first child E can be repeated. Actually the standard is: The first child is executed. Then we can have a loop that does the second child and then the first child again. The loop can be broken by skipping the second child. However in the code the loop is defined with two children: E P. So the structure is interpreted as: E mandatory Then we can do: P and then E any number of times But note: the loop operator does not require the P to be done Actually the loop operator allows the second child to be skipped Let me clarify with the pm4py documentation: The LOOP operator in pm4py for process trees is defined as: The first child is executed. Then the second child can be executed as many times as we want but note that each execution of the second child must be followed by the first child Actually the standard description of the loop operator in process trees is: The first child is executed. Then we can choose to do the second child and then the first child again as long as we want. So the pattern is: E  P  E   This leads to: The claim can be evaluated multiple times each followed by an approval But note: the approval must come after an evaluation And then another evaluation This might not be an anomaly per se if the process requires multiple rounds of evaluation and approval. However it could be an anomaly if the business expects one evaluation and one approval. So we must check the intended process: the intended flow is R A E P N C. So only one evaluation and one approval. Therefore the loop allowing multiple evaluations and approvals is an anomaly."
  },
  {
    "Name": "Pattern Recognition - PE",
    "Text": "b. XOR that may skip customer notification N: The XOR is defined with two children: N skip. So it can either: Do N Notify Customer OR Do nothing skip This is an anomaly because the intended process requires a notification step N. Skipping notification might violate customer service commitments or regulatory requirements."
  },
  {
    "Name": "Pattern Recognition - PE",
    "Text": "c. Partial ordering allowing premature closing: The partial order has: R  A A  loop which is E and P in loop loop  xor which is either N or skip And also: A  C directly from A to C This means that after assigning the adjuster A we can choose to skip the loop E and P and the XOR N and go directly to C Close Claim. This bypasses the core activities: evaluation approval and notification. This is clearly an anomaly because the claim should be evaluated and approved before closing. Also note: the loop is connected to XOR and XOR to nothing But the partial order also has an edge from A to C. This allows two paths: One: R A loop XOR C Another: R A C   if we skip the loop and the XOR This premature closing is a serious anomaly."
  },
  {
    "Name": "Hypothesis Generation - PE",
    "Text": "2. Generate hypotheses on why these anomalies might exist: a. Loop between E and P: Hypothesis 1: The claim process might have a scenario where after an approval new information might come to light that requires a re-evaluation. However the intended process did not account for this and the model was extended with a loop to handle such cases without a proper redesign. Hypothesis 2: There might be a misunderstanding of the claim process by the modeler. They might have thought that after approval the same adjuster or a different one might re-evaluate for example for fraud checks and then re-approve but the intended process does not require multiple approvals. Hypothesis 3: Change in business rules: perhaps the business introduced a quality check step after approval that might require a re-evaluation and then a re-approval But this was not reflected in the ideal process flow."
  },
  {
    "Name": "Hypothesis Generation - PE",
    "Text": "b. XOR skipping notification: Hypothesis 1: In some cases the customer might have opted out of notification or the claim might be settled without the need for notification e.g. auto-settled. But the business rules might require that only under certain conditions and the model does not enforce these conditions. Hypothesis 2: Technical issue: the system might have a bug that sometimes fails to send the notification and the model was updated to allow the process to continue even if the notification fails. Hypothesis 3: Miscommunication: the business process owner might have wanted to allow skipping notification in certain cases but this was not properly documented or controlled in the tool."
  },
  {
    "Name": "Hypothesis Generation - PE",
    "Text": "c. Premature closing: Hypothesis 1: There might be a class of claims that are considered fast-track and do not require evaluation and approval e.g. claims below a certain amount. The business might have introduced a shortcut but the model does not check the claim amount and allows skipping for any claim. Hypothesis 2: Technical error: the workflow system might have a bug that allows the claim to be closed without following the entire process due to a race condition or a missing transition. Hypothesis 3: Inadequate constraints in the modeling tool: the tool might have allowed adding the edge from A to C without validating the necessary steps and the modeler made a mistake."
  },
  {
    "Name": "Validation - PE",
    "Text": "3. Propose database queries to verify these hypotheses: We have the following tables: claims: claim_id customer_id claim_amount claim_type submission_date adjusters: adjuster_id name specialization region claim_events: event_id claim_id activity timestamp resource additional_info We assume that the events in claim_events have activity labels that correspond to R A E P N C. a. Loop between E and P multiple approvals per claim: Hypothesis: A claim might have multiple pairs of E P events. Query: Find claims that have more than one approval event P or more than one evaluation event E in a non-sequential manner Actually we want to see if a claim has more than one approval event because the intended process only has one. However note the loop: E P repeated. So we should see multiple E and multiple P events per claim. Query for claims with multiple approvals P per claim: SELECT claim_id COUNT as count FROM claim_events WHERE activity = P GROUP BY claim_id HAVING COUNT 1 Similarly for multiple evaluations: SELECT claim_id COUNT as count FROM claim_events WHERE activity = E GROUP BY claim_id HAVING COUNT 1 But note: the loop requires that each P is preceded by an E We can also check the sequence of events per claim. To see the pattern of events we can get the sequence of activities for a claim: SELECT claim_id ARRAY_AGG activity ORDER BY timestamp as sequence FROM claim_events GROUP BY claim_id Then we can look for sequences that contain multiple E and P and especially patterns like E P E P"
  },
  {
    "Name": "Validation - PE",
    "Text": "b. XOR skipping notification N: Hypothesis: Some claims are closed without a notification event N. Query: Find closed claims with a C event that do not have a notification event N. SELECT c.claim_id FROM claims c JOIN claim_events e ON c.claim_id = e.claim_id  Ensure there is a close event WHERE e.activity = C GROUP BY c.claim_id  Check for absence of notification event HAVING COUNT CASE WHEN e.activity = N THEN 1 END = 0 But note: we must be cautious. We should also check that the claim was closed and that there is no N event."
  },
  {
    "Name": "Validation - PE",
    "Text": "c. Premature closing: Hypothesis: Some claims are closed before having the required events. We want to find claims that: Have a close event C without having an evaluation E and or approval P and or notification N. However note that the anomaly allows skipping the entire loop and the XOR. So we might have: Claims with no E P and N events. Also we can check for claims that have the close event too early without the required steps. We can break it down: i. Closing without evaluation E: SELECT c.claim_id FROM claims c JOIN claim_events e ON c.claim_id = e.claim_id WHERE e.activity = C GROUP BY c.claim_id HAVING COUNT CASE WHEN e.activity = E THEN 1 END = 0 ii. Closing without approval P: SELECT c.claim_id FROM claims c JOIN claim_events e ON c.claim_id = e.claim_id WHERE e.activity = C GROUP BY c.claim_id HAVING COUNT CASE WHEN e.activity = P THEN 1 END = 0 iii. Closing without notification N  we already have a query for that but note: the premature closing might also skip notification So the above queries for skipping E or P will include those that skip everything. However we want to specifically check the scenario where the claim is closed right after A We can look for the sequence: R A C. We can get the sequence of events per claim and look for claims that have: A C event that occurs after an A event and without any E P or N in between But note: its possible that there are other events in between that are not part of the main activities We should consider only the main activities R A E P N C and check the order. We can use window functions to check the order of events per claim: WITH ordered_events AS  SELECT  claim_id   activity   timestamp   LAG activity OVER PARTITION BY claim_id ORDER BY timestamp AS prev_activity FROM claim_events WHERE activity IN R A E P N C SELECT claim_id FROM ordered_events WHERE activity = C   AND prev_activity = A GROUP BY claim_id This will find claims where the close event C immediately follows the assign adjuster A event meaning no E P or N events in between But note: there might be other events in between The LAG function only checks the immediate previous event. However if there are other events like a system event then the previous activity of C might not be A. So we need a more robust check. Alternatively we can check for the existence of any E P or N event that occurs between A and C  SELECT c.claim_id FROM claims c  Get the claim with events JOIN claim_events e_start ON c.claim_id = e_start.claim_id AND e_start.activity = A JOIN claim_events e_close ON c.claim_id = e_close.claim_id AND e_close.activity = C WHERE e_close.timestamp  e_start.timestamp  Check that there is no E P or N event between A and C AND NOT EXISTS   SELECT 1   FROM claim_events e_middle   WHERE e_middle.claim_id = c.claim_id     AND e_middle.activity IN E P N     AND e_middle.timestamp  e_start.timestamp     AND e_middle.timestamp  e_close.timestamp  This query finds claims that have: An assign adjuster A event and a close C event with C after A. And there is no event of type E P or N between A and C. This would indicate that the claim was closed immediately after being assigned without evaluation approval or notification."
  },
  {
    "Name": "Validation - IND",
    "Text": "d. Additionally we might want to check for claims that have multiple approvals and also check if they are closed prematurely But note: the premature closing anomaly is about skipping the entire loop so its a separate issue. However we can also look for the presence of the loop in the data: multiple E and P events that form a loop pattern. To check for the loop pattern we can look for sequences that have at least two E and two P events and the pattern is E P E P We can use the array of activities per claim and then look for the pattern: WITH claim_sequences AS  SELECT   claim_id   ARRAY_AGG activity ORDER BY timestamp as sequence FROM claim_events WHERE activity IN E P  only consider E and P for the pattern GROUP BY claim_id SELECT claim_id sequence FROM claim_sequences WHERE sequence  ARRAY E P varchar  must contain at least one E and one P AND array_length sequence 1  2  at least two events But note: we want to see if there are multiple E and P. Actually we want to see if there is a repetition. We can check: WITH claim_sequences AS  SELECT   claim_id   ARRAY_AGG activity ORDER BY timestamp as sequence FROM claim_events WHERE activity IN E P GROUP BY claim_id SELECT claim_id sequence FROM claim_sequences WHERE sequence  ARRAY E P varchar  must contain at least one of each  And also we want to see if the sequence is not just a single E followed by a single P   We can check for a repetition of the pattern   Alternatively we can look for claims that have more than one E or more than one P   But we already have a query for that. So we can combine. Actually the previous queries for counting E and P per claim are more straightforward."
  },
  {
    "Name": "Validation - PE",
    "Text": "e. We might also want to check if the skipped activities are correlated with claim type amount or adjuster For example are claims with small amounts being closed prematurely Or are certain adjusters skipping notifications For premature closing: SELECT  c.claim_type   c.claim_amount   AVG c.claim_amount as avg_amount   COUNT as count FROM claims c  Use the above premature closing condition with the subquery for no E P N between A and C JOIN   SELECT c_inner.claim_id   FROM claims c_inner   JOIN claim_events e_start ON c_inner.claim_id = e_start.claim_id AND e_start.activity = A   JOIN claim_events e_close ON c_inner.claim_id = e_close.claim_id AND e_close.activity = C   WHERE e_close.timestamp  e_start.timestamp   AND NOT EXISTS    SELECT 1    FROM claim_events e_middle    WHERE e_middle.claim_id = c_inner.claim_id      AND e_middle.activity IN E P N      AND e_middle.timestamp  e_start.timestamp      AND e_middle.timestamp  e_close.timestamp   premature ON c.claim_id = premature.claim_id GROUP BY c.claim_type c.claim_amount But note: grouping by claim_amount might be too granular. We can group by claim_type and then by amount ranges Or we can just look at the distribution by claim_type and average amount. Similarly for skipped notifications: SELECT  c.claim_type   c.claim_amount   AVG c.claim_amount as avg_amount   COUNT as count FROM claims c JOIN   SELECT c_inner.claim_id   FROM claims c_inner   JOIN claim_events e ON c_inner.claim_id = e.claim_id   WHERE e.activity = C   GROUP BY c_inner.claim_id   HAVING COUNT CASE WHEN e.activity = N THEN 1 END = 0 skipped ON c.claim_id = skipped.claim_id GROUP BY c.claim_type"
  },
  {
    "Name": "Validation - IND",
    "Text": "4. Summary of queries: We will write the following queries: a. For multiple approvals P per claim: SELECT claim_id COUNT as count FROM claim_events WHERE activity = P GROUP BY claim_id HAVING COUNT 1 b. For multiple evaluations E per claim: SELECT claim_id COUNT as count FROM claim_events WHERE activity = E GROUP BY claim_id HAVING COUNT 1 c. For claims closed without notification N: SELECT c.claim_id FROM claims c JOIN claim_events e ON c.claim_id = e.claim_id AND e.activity = C GROUP BY c.claim_id HAVING COUNT CASE WHEN e.activity = N THEN 1 END = 0 d. For claims closed prematurely without any E P or N between A and C: SELECT c.claim_id FROM claims c JOIN claim_events e_start ON c.claim_id = e_start.claim_id AND e_start.activity = A JOIN claim_events e_close ON c.claim_id = e_close.claim_id AND e_close.activity = C WHERE e_close.timestamp  e_start.timestamp AND NOT EXISTS   SELECT 1   FROM claim_events e_middle   WHERE e_middle.claim_id = c.claim_id     AND e_middle.activity IN E P N     AND e_middle.timestamp  e_start.timestamp     AND e_middle.timestamp  e_close.timestamp  e. For claims with multiple approvals by adjuster and claim type to see if there is a pattern: SELECT  c.claim_type   COUNT as count   ARRAY_AGG DISTINCT a.specialization as adjuster_specializations FROM claims c JOIN claim_events ce ON c.claim_id = ce.claim_id AND ce.activity = P JOIN adjusters a ON ce.resource INTEGER = a.adjuster_id   assuming resource is adjuster_id and cast to integer GROUP BY c.claim_id c.claim_type HAVING COUNT ce.event_id 1 ORDER BY c.claim_id But note: the adjuster might be the same or different We are joining on ce.resource which is a string We have to assume that for P events the resource is an adjuster_id. We need to check the data. Alternatively we might not have adjuster_id in the resource for all P events So we might do: WITH multiple_approvals AS   SELECT claim_id   FROM claim_events   WHERE activity = P   GROUP BY claim_id   HAVING COUNT 1 SELECT  c.claim_type   c.claim_amount   COUNT as count FROM multiple_approvals ma JOIN claims c ON ma.claim_id = c.claim_id GROUP BY c.claim_type c.claim_amount But if we want to include adjuster information we must be cautious because not every P event might have an adjuster_id in the resource We might have to look at the events and see. f. For adjusters associated with premature closures: We can look at the adjuster assigned from the A event for claims that were closed prematurely. WITH premature_claims AS   SELECT c.claim_id   FROM claims c   JOIN claim_events e_start ON c.claim_id = e_start.claim_id AND e_start.activity = A   JOIN claim_events e_close ON c.claim_id = e_close.claim_id AND e_close.activity = C   WHERE e_close.timestamp  e_start.timestamp   AND NOT EXISTS    SELECT 1    FROM claim_events e_middle    WHERE e_middle.claim_id = c.claim_id      AND e_middle.activity IN E P N      AND e_middle.timestamp  e_start.timestamp      AND e_middle.timestamp  e_close.timestamp  SELECT  a.adjuster_id   a.name   COUNT as count FROM premature_claims pc JOIN claim_events ce ON pc.claim_id = ce.claim_id AND ce.activity = A JOIN adjusters a ON ce.resource INTEGER = a.adjuster_id   assuming resource is adjuster_id and cast to integer GROUP BY a.adjuster_id a.name g. For claims with multiple approvals check if they are followed by a close event and if so when Also are they closed after the last approval We can get the last event per claim and see if it is C. But note: we already have the close event. We can check the sequence per claim. We can write a query to get the entire sequence for claims that have multiple approvals and then see the pattern. However due to the complexity we might use the array_agg as before. We have provided several queries to verify the hypotheses. The actual execution of these queries on the database will help in identifying the extent of the anomalies and possibly point to patterns e.g. by claim type amount or adjuster that can help in forming conclusions."
  },
  {
    "Name": "Conclusion - C"
  }
]