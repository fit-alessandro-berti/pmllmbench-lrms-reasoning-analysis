[
  {
    "Name": "Pattern Recognition - PE",
    "Text": "We need to model: 1. Sequence: A -> RG -> IA 2. Then sequence: TI -> TC 3. Then XOR (CE, FBP) after triage."
  },
  {
    "Name": "Deductive Reasoning - PE",
    "Text": "4. Then loop: loop body is SC followed by XOR (TM, SPT) then RDT which is XOR (FCE, FBA). Loop condition: after RDT, if abnormal, repeat loop; else exit. So loop operator with A (body) = SC + (TM XOR SPT) -> RDT? Actually loop operator in pm4py expects two children: first is the do part (body), second is the redo part (condition). In description: * (A,B) means execute A, then either exit or execute B then A again."
  },
  {
    "Name": "Hypothesis Generation - PE",
    "Text": "Thus we can have: - root: SEQUENCE of many parts. Sequence: [A, RG, IA, TI, TC, XOR(initial test), LOOP(loopNode), PARALLEL(AI, NC), SEQUENCE(FAS, DDI), PARALLEL(BL, ICP, MRF)]"
  },
  {
    "Name": "Abductive Reasoning - PE",
    "Text": "Loop node: children: first = tau (or maybe a silent step representing exit condition)? Actually we need to model that after initial test, we may go into loop if abnormal. So we can have loop node with first child = tau (representing skip loop) and second child = loopBody. In pm4py, loop operator expects two children: first is the do part (executed before loop), second is the redo part (executed after condition). But we want to repeat loop body until normal. So we can set first child = tau (or maybe a silent step) and second child = loopBody. The loopBody is a SEQUENCE of SC, XOR(Treatment), RDT (XOR(FCE,FBA)). So loop node children: [tau, loopBody]. The loop will execute loopBody repeatedly until condition satisfied (i.e., after loopBody we go back to loop node). Thats fine."
  },
  {
    "Name": "Heuristic Reasoning - IND",
    "Text": "Thus overall tree. We need to construct code accordingly, setting parents and children. Will produce code with imports, create nodes, set parents, append children. Will also provide a textual representation using operators: something like: A -> RG -> IA -> TI -> TC -> X(CE, FBP) -> *(tau, SC -> X(TM, SPT) -> X(FCE, FBA) ) -> +(AI, NC) -> FAS -> DDI -> +(BL, ICP, MRF) But need proper notation: + for parallel with two children; for three we can nest. Will output LaTeX."
  },
  {
    "Name": "Conclusion - C"
  }
]